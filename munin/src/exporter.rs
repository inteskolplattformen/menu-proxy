use std::{
    convert::{TryFrom, TryInto},
    fs::{create_dir, OpenOptions},
    path::PathBuf,
    time::Instant,
};

use chrono::NaiveDate;
use database::models::{Day, MenuId};
use database::schema::days::table as days_table;
use diesel::{PgConnection, QueryDsl, RunQueryDsl};
use hugin::Meal;
use serde::Serialize;
use structopt::StructOpt;
use thiserror::Error;
use tracing::info;

#[derive(Debug, Serialize)]
struct ExportedDay {
    menu_id: MenuId,
    date: NaiveDate,
    meals: String,
}

impl TryFrom<Day> for ExportedDay {
    type Error = serde_json::Error;

    fn try_from(d: Day) -> Result<Self, Self::Error> {
        let Day {
            date,
            meals,
            menu_id,
        } = d;
        let meals: Vec<Meal> = meals.into();

        Ok(Self {
            menu_id,
            date,
            meals: serde_json::to_string(&meals)?,
        })
    }
}

#[derive(Debug, Error)]
pub enum ExporterError {
    #[error("sql error: {0}")]
    Diesel(#[from] diesel::result::Error),

    #[error("io error: {0}")]
    Io(#[from] std::io::Error),

    #[error("csv error: {0}")]
    Csv(#[from] csv::Error),

    #[error("json error: {0}")]
    Json(#[from] serde_json::Error),
}

type ExporterResult<T> = Result<T, ExporterError>;

#[derive(Debug, StructOpt)]
pub struct ExporterOpt {
    #[structopt(short, long)]
    output: PathBuf,

    #[structopt(long, default_value = "100000")]
    chunk_size: i64,
}

pub fn export(connection: &PgConnection, opt: &ExporterOpt) -> ExporterResult<()> {
    create_dir(&opt.output)?;

    let menus_file = OpenOptions::new()
        .write(true)
        .create_new(true)
        .open(opt.output.join("menus.csv"))?;
    let mut menus_w = csv::Writer::from_writer(menus_file);

    // writeln!(&mut menus_buf, "# Generated by {} v{}", env!("CARGO_PKG_NAME"), env!("CARGO_PKG_VERSION"))?;

    let days_file = OpenOptions::new()
        .write(true)
        .create_new(true)
        .open(opt.output.join("days.csv"))?;
    let mut days_w = csv::Writer::from_writer(days_file);

    connection
        .build_transaction()
        .repeatable_read()
        .read_only()
        .run::<_, ExporterError, _>(|| {
            let _start = Instant::now();

            // let menus = menus_table.load::<Menu>(connection)?;

            // for menu in menus {
            //   menus_w.serialize(menu)?;
            // }

            let mut offset = 0;

            loop {
                let days = days_table
                    .offset(offset)
                    .limit(opt.chunk_size)
                    .load::<Day>(connection)?;
                let num_days = days.len();

                info!("loaded {} days", num_days);

                for day in days {
                    let day: ExportedDay = day.try_into()?;
                    days_w.serialize(day)?;
                }

                if (num_days as i64) < opt.chunk_size {
                    break;
                }

                offset += opt.chunk_size;
            }

            Ok(())
        })?;

    menus_w.flush()?;
    days_w.flush()?;

    Ok(())
}
